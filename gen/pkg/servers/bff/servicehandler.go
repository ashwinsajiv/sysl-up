// Code generated by sysl DO NOT EDIT.
package up

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/anz-bank/sysl-go/common"
	"github.com/anz-bank/sysl-go/config"
	"github.com/anz-bank/sysl-go/convert"
	"github.com/anz-bank/sysl-go/core"
	"github.com/anz-bank/sysl-go/core/authrules"
	"github.com/anz-bank/sysl-go/restlib"
	"github.com/anz-bank/sysl-go/validator"

	"github.com/ashwinsajiv/sysl-up/gen/pkg/servers/bff/up"
)

// Handler interface for Up
type Handler interface {
	DeleteTransactionsRelationshipsTagsHandler(w http.ResponseWriter, r *http.Request)
	DeleteWebhooksHandler(w http.ResponseWriter, r *http.Request)
	GetAccountsListHandler(w http.ResponseWriter, r *http.Request)
	GetAccountsTransactionsListHandler(w http.ResponseWriter, r *http.Request)
	GetAccountsHandler(w http.ResponseWriter, r *http.Request)
	GetCategoriesListHandler(w http.ResponseWriter, r *http.Request)
	GetCategoriesHandler(w http.ResponseWriter, r *http.Request)
	GetTagsListHandler(w http.ResponseWriter, r *http.Request)
	GetTransactionsListHandler(w http.ResponseWriter, r *http.Request)
	GetTransactionsHandler(w http.ResponseWriter, r *http.Request)
	GetUtilPingListHandler(w http.ResponseWriter, r *http.Request)
	GetV1AccountsListHandler(w http.ResponseWriter, r *http.Request)
	GetWebhooksListHandler(w http.ResponseWriter, r *http.Request)
	GetWebhooksHandler(w http.ResponseWriter, r *http.Request)
	GetWebhooksLogsListHandler(w http.ResponseWriter, r *http.Request)
	PostTransactionsRelationshipsTagsHandler(w http.ResponseWriter, r *http.Request)
	PostWebhooksHandler(w http.ResponseWriter, r *http.Request)
	PostWebhooksPingHandler(w http.ResponseWriter, r *http.Request)
}

// ServiceHandler for Up API
type ServiceHandler struct {
	genCallback        core.RestGenCallback
	serviceInterface   *ServiceInterface
	authorizationRules map[string]authrules.Rule
	upService          up.Service
}

// NewServiceHandler for Up
func NewServiceHandler(
	ctx context.Context,
	cfg *config.DefaultConfig,
	hooks *core.Hooks,
	genCallback core.RestGenCallback,
	serviceInterface *ServiceInterface,
	upUpService up.Service,
) (*ServiceHandler, error) {

	authorizationRules := make(map[string]authrules.Rule)

	return &ServiceHandler{
		genCallback,
		serviceInterface,
		authorizationRules,
		upUpService,
	}, nil
}

// DeleteTransactionsRelationshipsTagsHandler ...
func (s *ServiceHandler) DeleteTransactionsRelationshipsTagsHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.DeleteTransactionsRelationshipsTags == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req DeleteTransactionsRelationshipsTagsRequest

	req.TransactionId = restlib.GetURLParam(r, "transactionId")

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := DeleteTransactionsRelationshipsTagsClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	err := s.serviceInterface.DeleteTransactionsRelationshipsTags(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, nil)
}

// DeleteWebhooksHandler ...
func (s *ServiceHandler) DeleteWebhooksHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.DeleteWebhooks == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req DeleteWebhooksRequest

	req.ID = restlib.GetURLParam(r, "id")

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := DeleteWebhooksClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	err := s.serviceInterface.DeleteWebhooks(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, nil)
}

// GetAccountsListHandler ...
func (s *ServiceHandler) GetAccountsListHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetAccountsList == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetAccountsListRequest

	var PageSizeParam string

	var convErr error
	PageSizeParam = restlib.GetQueryParam(r, "page[size]")
	req.PageSize, convErr = convert.StringToIntPtr(ctx, PageSizeParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetAccountsListClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	listaccountsresponse, err := s.serviceInterface.GetAccountsList(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, listaccountsresponse)
}

// GetAccountsTransactionsListHandler ...
func (s *ServiceHandler) GetAccountsTransactionsListHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetAccountsTransactionsList == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetAccountsTransactionsListRequest

	req.AccountId = restlib.GetURLParam(r, "accountId")

	var PageSizeParam string

	var FilterStatusParam string

	var FilterSinceParam string

	var FilterUntilParam string

	var FilterCategoryParam string

	var FilterTagParam string

	var convErr error
	PageSizeParam = restlib.GetQueryParam(r, "page[size]")
	FilterStatusParam = restlib.GetQueryParam(r, "filter[status]")
	FilterSinceParam = restlib.GetQueryParam(r, "filter[since]")
	FilterUntilParam = restlib.GetQueryParam(r, "filter[until]")
	FilterCategoryParam = restlib.GetQueryParam(r, "filter[category]")
	FilterTagParam = restlib.GetQueryParam(r, "filter[tag]")
	req.PageSize, convErr = convert.StringToIntPtr(ctx, PageSizeParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}
	req.FilterStatus, convErr = convert.StringToStringPtr(ctx, FilterStatusParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}
	req.FilterSince, convErr = convert.StringToTimePtr(ctx, FilterSinceParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}
	req.FilterUntil, convErr = convert.StringToTimePtr(ctx, FilterUntilParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}
	req.FilterCategory, convErr = convert.StringToStringPtr(ctx, FilterCategoryParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}
	req.FilterTag, convErr = convert.StringToStringPtr(ctx, FilterTagParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetAccountsTransactionsListClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	listtransactionsresponse, err := s.serviceInterface.GetAccountsTransactionsList(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, listtransactionsresponse)
}

// GetAccountsHandler ...
func (s *ServiceHandler) GetAccountsHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetAccounts == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetAccountsRequest

	req.ID = restlib.GetURLParam(r, "id")

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetAccountsClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	getaccountresponse, err := s.serviceInterface.GetAccounts(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, getaccountresponse)
}

// GetCategoriesListHandler ...
func (s *ServiceHandler) GetCategoriesListHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetCategoriesList == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetCategoriesListRequest

	var FilterParentParam string

	var convErr error
	FilterParentParam = restlib.GetQueryParam(r, "filter[parent]")
	req.FilterParent, convErr = convert.StringToStringPtr(ctx, FilterParentParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetCategoriesListClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	listcategoriesresponse, err := s.serviceInterface.GetCategoriesList(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, listcategoriesresponse)
}

// GetCategoriesHandler ...
func (s *ServiceHandler) GetCategoriesHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetCategories == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetCategoriesRequest

	req.ID = restlib.GetURLParam(r, "id")

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetCategoriesClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	getcategoryresponse, err := s.serviceInterface.GetCategories(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, getcategoryresponse)
}

// GetTagsListHandler ...
func (s *ServiceHandler) GetTagsListHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetTagsList == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetTagsListRequest

	var PageSizeParam string

	var convErr error
	PageSizeParam = restlib.GetQueryParam(r, "page[size]")
	req.PageSize, convErr = convert.StringToIntPtr(ctx, PageSizeParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetTagsListClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	listtagsresponse, err := s.serviceInterface.GetTagsList(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, listtagsresponse)
}

// GetTransactionsListHandler ...
func (s *ServiceHandler) GetTransactionsListHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetTransactionsList == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetTransactionsListRequest

	var PageSizeParam string

	var FilterStatusParam string

	var FilterSinceParam string

	var FilterUntilParam string

	var FilterCategoryParam string

	var FilterTagParam string

	var convErr error
	PageSizeParam = restlib.GetQueryParam(r, "page[size]")
	FilterStatusParam = restlib.GetQueryParam(r, "filter[status]")
	FilterSinceParam = restlib.GetQueryParam(r, "filter[since]")
	FilterUntilParam = restlib.GetQueryParam(r, "filter[until]")
	FilterCategoryParam = restlib.GetQueryParam(r, "filter[category]")
	FilterTagParam = restlib.GetQueryParam(r, "filter[tag]")
	req.PageSize, convErr = convert.StringToIntPtr(ctx, PageSizeParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}
	req.FilterStatus, convErr = convert.StringToStringPtr(ctx, FilterStatusParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}
	req.FilterSince, convErr = convert.StringToTimePtr(ctx, FilterSinceParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}
	req.FilterUntil, convErr = convert.StringToTimePtr(ctx, FilterUntilParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}
	req.FilterCategory, convErr = convert.StringToStringPtr(ctx, FilterCategoryParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}
	req.FilterTag, convErr = convert.StringToStringPtr(ctx, FilterTagParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetTransactionsListClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	listtransactionsresponse, err := s.serviceInterface.GetTransactionsList(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, listtransactionsresponse)
}

// GetTransactionsHandler ...
func (s *ServiceHandler) GetTransactionsHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetTransactions == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetTransactionsRequest

	req.ID = restlib.GetURLParam(r, "id")

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetTransactionsClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	gettransactionresponse, err := s.serviceInterface.GetTransactions(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, gettransactionresponse)
}

// GetUtilPingListHandler ...
func (s *ServiceHandler) GetUtilPingListHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetUtilPingList == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetUtilPingListRequest

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetUtilPingListClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	pingresponse, err := s.serviceInterface.GetUtilPingList(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, pingresponse)
}

// GetV1AccountsListHandler ...
func (s *ServiceHandler) GetV1AccountsListHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetV1AccountsList == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetV1AccountsListRequest

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetV1AccountsListClient{
		UpGetAccountsList: s.upService.GetAccountsList,
	}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	err := s.serviceInterface.GetV1AccountsList(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, nil)
}

// GetWebhooksListHandler ...
func (s *ServiceHandler) GetWebhooksListHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetWebhooksList == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetWebhooksListRequest

	var PageSizeParam string

	var convErr error
	PageSizeParam = restlib.GetQueryParam(r, "page[size]")
	req.PageSize, convErr = convert.StringToIntPtr(ctx, PageSizeParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetWebhooksListClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	listwebhooksresponse, err := s.serviceInterface.GetWebhooksList(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, listwebhooksresponse)
}

// GetWebhooksHandler ...
func (s *ServiceHandler) GetWebhooksHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetWebhooks == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetWebhooksRequest

	req.ID = restlib.GetURLParam(r, "id")

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetWebhooksClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	getwebhookresponse, err := s.serviceInterface.GetWebhooks(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, getwebhookresponse)
}

// GetWebhooksLogsListHandler ...
func (s *ServiceHandler) GetWebhooksLogsListHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.GetWebhooksLogsList == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req GetWebhooksLogsListRequest

	req.WebhookId = restlib.GetURLParam(r, "webhookId")

	var PageSizeParam string

	var convErr error
	PageSizeParam = restlib.GetQueryParam(r, "page[size]")
	req.PageSize, convErr = convert.StringToIntPtr(ctx, PageSizeParam)
	if convErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", convErr, s.genCallback.MapError)
		return
	}

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := GetWebhooksLogsListClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	listwebhookdeliverylogsresponse, err := s.serviceInterface.GetWebhooksLogsList(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, listwebhookdeliverylogsresponse)
}

// PostTransactionsRelationshipsTagsHandler ...
func (s *ServiceHandler) PostTransactionsRelationshipsTagsHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.PostTransactionsRelationshipsTags == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req PostTransactionsRelationshipsTagsRequest
	decoder := json.NewDecoder(r.Body)
	decodeErr := decoder.Decode(&req.Request)
	if decodeErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Error reading request body", decodeErr, s.genCallback.MapError)
		return
	}
	req.TransactionId = restlib.GetURLParam(r, "transactionId")

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := PostTransactionsRelationshipsTagsClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	err := s.serviceInterface.PostTransactionsRelationshipsTags(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, nil)
}

// PostWebhooksHandler ...
func (s *ServiceHandler) PostWebhooksHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.PostWebhooks == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req PostWebhooksRequest
	decoder := json.NewDecoder(r.Body)
	decodeErr := decoder.Decode(&req.Request)
	if decodeErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Error reading request body", decodeErr, s.genCallback.MapError)
		return
	}

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := PostWebhooksClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	createwebhookresponse, err := s.serviceInterface.PostWebhooks(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, createwebhookresponse)
}

// PostWebhooksPingHandler ...
func (s *ServiceHandler) PostWebhooksPingHandler(w http.ResponseWriter, r *http.Request) {
	if s.serviceInterface.PostWebhooksPing == nil {
		common.HandleError(r.Context(), w, common.InternalError, "not implemented", nil, s.genCallback.MapError)
		return
	}

	ctx := common.RequestHeaderToContext(r.Context(), r.Header)
	ctx = common.RespHeaderAndStatusToContext(ctx, make(http.Header), http.StatusOK)
	var req PostWebhooksPingRequest
	decoder := json.NewDecoder(r.Body)
	decodeErr := decoder.Decode(&req.Request)
	if decodeErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Error reading request body", decodeErr, s.genCallback.MapError)
		return
	}
	req.WebhookId = restlib.GetURLParam(r, "webhookId")

	ctx, cancel := s.genCallback.DownstreamTimeoutContext(ctx)
	defer cancel()
	valErr := validator.Validate(&req)
	if valErr != nil {
		common.HandleError(ctx, w, common.BadRequestError, "Invalid request", valErr, s.genCallback.MapError)
		return
	}

	client := PostWebhooksPingClient{}

	defer func() {
		if rec := recover(); rec != nil {
			var err error
			switch rec := rec.(type) {
			case error:
				err = rec
			default:
				err = fmt.Errorf("Unknown error: %v", rec)
			}
			common.HandleError(ctx, w, common.InternalError, "Unexpected panic", err, s.genCallback.MapError)
		}
	}()
	webhookeventcallback, err := s.serviceInterface.PostWebhooksPing(ctx, &req, client)
	if err != nil {
		common.HandleError(ctx, w, common.InternalError, "Handler error", err, s.genCallback.MapError)
		return
	}

	headermap, httpstatus := common.RespHeaderAndStatusFromContext(ctx)
	if headermap.Get("Content-Type") == "" {
		headermap.Set("Content-Type", "application/json")
	}
	restlib.SetHeaders(w, headermap)
	restlib.SendHTTPResponse(w, httpstatus, webhookeventcallback)
}
